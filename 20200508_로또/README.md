<<<<<<< HEAD
# 6603_로또 

독일 로또는 {1, 2, ..., 49}에서 수 6개를 고른다.

로또 번호를 선택하는데 사용되는 가장 유명한 전략은 49가지 수 중 k(k>6)개의 수를 골라 집합 S를 만든 다음 그 수만 가지고 번호를 선택하는 것이다.

예를 들어, k=8, S={1,2,3,5,8,13,21,34}인 경우 이 집합 S에서 수를 고를 수 있는 경우의 수는 총 28가지이다. ([1,2,3,5,8,13], [1,2,3,5,8,21], [1,2,3,5,8,34], [1,2,3,5,13,21], ..., [3,5,8,13,21,34])

집합 S와 k가 주어졌을 때, 수를 고르는 모든 방법을 구하는 프로그램을 작성하시오.    

**입력**  
입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있다. 첫 번째 수는 k (6 < k < 13)이고, 다음 k개 수는 집합 S에 포함되는 수이다. S의 원소는 오름차순으로 주어진다.

입력의 마지막 줄에는 0이 하나 주어진다.    

**출력**  
각 테스트 케이스마다 수를 고르는 모든 방법을 출력한다. 이때, 사전 순으로 출력한다.

각 테스트 케이스 사이에는 빈 줄을 하나 출력한다.

**Example1:**   
```
7 1 2 3 4 5 6 7
8 1 2 3 5 8 13 21 34
0

1 2 3 4 5 6
1 2 3 4 5 7
1 2 3 4 6 7
1 2 3 5 6 7
1 2 4 5 6 7
1 3 4 5 6 7
2 3 4 5 6 7

1 2 3 5 8 13
1 2 3 5 8 21
1 2 3 5 8 34
1 2 3 5 13 21
1 2 3 5 13 34
1 2 3 5 21 34
1 2 3 8 13 21
1 2 3 8 13 34
1 2 3 8 21 34
1 2 3 13 21 34
1 2 5 8 13 21
1 2 5 8 13 34
1 2 5 8 21 34
1 2 5 13 21 34
1 2 8 13 21 34
1 3 5 8 13 21
1 3 5 8 13 34
1 3 5 8 21 34
1 3 5 13 21 34
1 3 8 13 21 34
1 5 8 13 21 34
2 3 5 8 13 21
2 3 5 8 13 34
2 3 5 8 21 34
2 3 5 13 21 34
2 3 8 13 21 34
2 5 8 13 21 34
3 5 8 13 21 34
```

## trial1
### Intuition
```
BFS를 이용하여 익은 토마토가 있는 위치에서 모든 방향에 대해 탐색한다.
tomato라는 이름의 queue에 먼저 익은 토마토의 위치를 넣고 인접한 부분에 익지 않는 토마토의 위치를 넣는다. 이것들을 모두 익은 토마토인 1로 변환한다.
마지막으로 익지 않은 토마토가 있는지 확인하고, 있으면 -1을 출력하였다.

visited 배열 없이 box에서 탐색하여 값을 업데이트 하도록 구현하였다.
```

### Codes  
```cpp
#include <iostream>
using namespace std;
#define MAX 13
int k;
int S[MAX];
int visited[MAX]={0,};

void dfs(int cur, int len){ //cur: 현재 위치 || len: 조합 길이
    if(cur==k&&len==6){
        for(int i=0;i<k;i++){
            if(visited[i]==1){
                cout<<S[i]<<" ";
            }
        }
        cout<<endl;
    }
    if(cur==k) return;
    visited[cur]=1;
    dfs(cur+1,len+1);
    visited[cur]=0;
    dfs(cur+1,len);
}

int main(){
    while(1){
        cin>>k;
        if(k==0) 
            break;
        for(int i=0;i<k;i++){
            cin>>S[i];
        }
        dfs(0,0);
        cout<<endl;
    }
    return 0;
}

```
### Results (Performance)  
**Runtime:**  56 ms O(n^2)
**Memory Usage:** 	1984 MB  


<p align="center"> 
<img src="./screen.JPG">
</p>


### 문제 URL (백준)  
https://www.acmicpc.net/problem/6603
=======
# codingPractice
coding practice
>>>>>>> cece3b883c91a6735a3bcace6008593058bf11bb
